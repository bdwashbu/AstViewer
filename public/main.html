<!doctype html>
<html>
<head>
    <title>Ast Viewer</title>

    <style>

      circle.node {
        cursor: pointer;
        stroke: #000;
        stroke-width: .5px;
        isClicked: false;
      }

      line.link {
        fill: none;
        stroke: #9ecae1;
        stroke-width: 1.5px;
      }

      .node text {
          pointer-events: none;
          font: 10px sans-serif;
        }

    </style>
</head>
<body>

<script type="text/javascript" src="js/d3.min.js"></script>

<script type="text/javascript">
// Define the dimensions of the visualization. We're using
// a size that's convenient for displaying the graphic on
// http://jsDataV.is

var width = 640,
    height = 480;

// Define the data for the example. In general, a force layout
// requires two data arrays. The first array, here named `nodes`,
// contains the object that are the focal point of the visualization.
// The second array, called `links` below, identifies all the links
// between the nodes. (The more mathematical term is "edges.")

// For the simplest possible example we only define two nodes. As
// far as D3 is concerned, nodes are arbitrary objects. Normally the
// objects wouldn't be initialized with `x` and `y` properties like
// we're doing below. When those properties are present, they tell
// D3 where to place the nodes before the force layout starts its
// magic. More typically, they're left out of the nodes and D3 picks
// random locations for each node. We're defining them here so we can
// get a consistent application of the layout which lets us see the
// effects of different properties.

var nodes = [
    { x:   width/3, y: height/2 },
    { x: 2*width/3, y: height/2 }
];

// The `links` array contains objects with a `source` and a `target`
// property. The values of those properties are the indices in
// the `nodes` array of the two endpoints of the link.

var links = [
    { source: 0, target: 1 }
];

// Here's were the code begins. We start off by creating an SVG
// container to hold the visualization. We only need to specify
// the dimensions for this container.

var svg = d3.select('body').append('svg')
    .attr('width', width)
    .attr('height', height);

// Now we create a force layout object and define its properties.
// Those include the dimensions of the visualization and the arrays
// of nodes and links.

var force = d3.layout.force()
    .size([width, height])
    .nodes(nodes)
    .links(links);

// There's one more property of the layout we need to define,
// its `linkDistance`. That's generally a configurable value and,
// for a first example, we'd normally leave it at its default.
// Unfortunately, the default value results in a visualization
// that's not especially clear. This parameter defines the
// distance (normally in pixels) that we'd like to have between
// nodes that are connected. (It is, thus, the length we'd
// like our links to have.)

force.linkDistance(width/2);

// Next we'll add the nodes and links to the visualization.
// Note that we're just sticking them into the SVG container
// at this point. We start with the links. The order here is
// important because we want the nodes to appear "on top of"
// the links. SVG doesn't really have a convenient equivalent
// to HTML's `z-index`; instead it relies on the order of the
// elements in the markup. By adding the nodes _after_ the
// links we ensure that nodes appear on top of links.

// Links are pretty simple. They're just SVG lines, and
// we're not even going to specify their coordinates. (We'll
// let the force layout take care of that.) Without any
// coordinates, the lines won't even be visible, but the
// markup will be sitting inside the SVG container ready
// and waiting for the force layout.

var link = svg.selectAll('.link')
    .data(links)
    .enter().append('line')
    .attr('class', 'link');

// Now it's the nodes turn. Each node is drawn as a circle.

var node = svg.selectAll('.node')
    .data(nodes)
    .enter().append('circle')
    .attr('class', 'node');

// We're about to tell the force layout to start its
// calculations. We do, however, want to know when those
// calculations are complete, so before we kick things off
// we'll define a function that we want the layout to call
// once the calculations are done.

force.on('end', function() {

    // When this function executes, the force layout
    // calculations have concluded. The layout will
    // have set various properties in our nodes and
    // links objects that we can use to position them
    // within the SVG container.

    // First let's reposition the nodes. As the force
    // layout runs it updates the `x` and `y` properties
    // that define where the node should be centered.
    // To move the node, we set the appropriate SVG
    // attributes to their new values. We also have to
    // give the node a non-zero radius so that it's visible
    // in the container.

    node.attr('r', width/25)
        .attr('cx', function(d) { return d.x; })
        .attr('cy', function(d) { return d.y; });

    // We also need to update positions of the links.
    // For those elements, the force layout sets the
    // `source` and `target` properties, specifying
    // `x` and `y` values in each case.

    link.attr('x1', function(d) { return d.source.x; })
        .attr('y1', function(d) { return d.source.y; })
        .attr('x2', function(d) { return d.target.x; })
        .attr('y2', function(d) { return d.target.y; });

});

// Okay, everything is set up now so it's time to turn
// things over to the force layout. Here we go.

force.start();

// By the time you've read this far in the code, the force
// layout has undoubtedly finished its work. Unless something
// went horribly wrong, you should see two light grey circles
// connected by a single dark grey line. If you have a screen
// ruler (such as [xScope](http://xscopeapp.com) handy, measure
// the distance between the centers of the two circles. It
// should be somewhere close to the `linkDistance` parameter we
// set way up in the beginning (480 pixels). That, in the most
// basic of all nutshells, is what a force layout does. We
// tell it how far apart we want connected nodes to be, and
// the layout keeps moving the nodes around until they get
// reasonably close to that value.

// Of course, there's quite a bit more than that going on
// under the hood. We'll take a closer look starting with
// the next example.


</script>

<!--<script type="text/javascript">-->
    <!--$(document).ready(function() {-->

      <!--var json = $jsonString;-->

            <!--var w = 1280,-->
                <!--h = 800,-->
                <!--node,-->
                <!--nodes,-->
                <!--links,-->
                <!--link,-->
                <!--root;-->

            <!--var force = d3.layout.force()-->
                <!--.on("tick", tick)-->
                <!--.charge(function(d) { return d.charge; })-->
                <!--.linkDistance(function(d) { return d.source.linkDistance; })-->
                <!--.linkStrength(function(d) {-->
                  <!--return 1.0;-->
                <!--})-->
                <!--//.chargeDistance(400)-->
                <!--//.gravity(0.2)-->
                <!--.friction(0.4)-->
                <!--.size([w, h - 160]);-->

            <!--var vis = d3.select("body").append("svg")-->
                <!--.attr("width", w)-->
                <!--.attr("height", h);-->

              <!--root = json;-->
              <!--root.fixed = true;-->
              <!--root.x = w / 2;-->
              <!--root.y = h / 2 - 80;-->



              <!--flatten(root).forEach(function(node) {-->

                  <!--if (node.children == null) {-->
                    <!--node._children = [];-->
                    <!--node.children = [];-->
                  <!--} else {-->
                    <!--node._children = node.children.slice();-->
                    <!--node.children = [];-->
                  <!--}-->
                  <!--if (node._children != null) {-->
                     <!--node._children.forEach(function(x) {-->
                        <!--x.parent = node;-->
                     <!--});-->
                  <!--}-->
                  <!--node.isCollapsed = true-->
                  <!--node.charge = 0-->
                  <!--node.chargeChange = 0.0-->
                  <!--node.linkDistanceChange = 0.0-->
                  <!--node.linkDistance = 100.0-->
                  <!--node.linkStrength = 0.0-->
                  <!--node.x = w / 2;-->
                  <!--node.y = h / 2 - 80;-->
                  <!--node.isClicked = false;-->
                  <!--node.growthSpeed = Math.floor((Math.random() * 4) + 1);-->
              <!--});-->



              <!--var currentNodesToUnfold = [root];-->

              <!--var elapsedTimer = 2000;-->

              <!--var isFirst = true;-->

              <!--function unfold(node) {-->

                  <!--node.isCollapsed = false;-->

                  <!--vis.selectAll("circle")-->
                        <!--.transition()-->
                        <!--.duration(1000)-->
                        <!--.attr("r", 6.0)-->
                        <!--.style('stroke-width', 0.5);-->


                  <!--while (node._children.length > 0) {-->
                    <!--openNode(node);-->
                  <!--}-->

                  <!--link.transition()-->
                      <!--.duration(1000)-->
                      <!--.style('stroke-width', 2.0)-->
                      <!--.style('stroke', '#000000')-->

                  <!--update();-->
              <!--}-->

              <!--update();-->
              <!--unfold(root);-->

            <!--function update() {-->
              <!--nodes = flatten(root),-->
              <!--links = d3.layout.tree().links(nodes);-->

              <!--// Restart the force layout.-->
              <!--force-->
                  <!--.nodes(nodes)-->
                  <!--.links(links)-->
                  <!--.start();-->



              <!--// Update the links…-->
              <!--link = vis.selectAll("line.link")-->
                  <!--.data(links, function(d) { return d.target.id; });-->

              <!--// Enter any new links.-->
              <!--link.enter().insert("svg:line", ".node")-->
                  <!--.attr("class", "link")-->
                  <!--.style('stroke-width', 4.0)-->
                  <!--.style('stroke', '#AA0000')-->
                  <!--.attr("x1", function(d) { return d.source.x; })-->
                  <!--.attr("y1", function(d) { return d.source.y; })-->
                  <!--.attr("x2", function(d) { return d.target.x; })-->
                  <!--.attr("y2", function(d) { return d.target.y; });-->


              <!--// Exit any old links.-->
              <!--link.exit().remove();-->



              <!--var newNodes = vis.selectAll("circle.node")-->
                  <!--.data(nodes, function(d) { return d.id; });-->

              <!--var newLabels = vis.selectAll("text")-->

              <!--// Update the nodes…-->
              <!--node = newNodes.enter().append("g")-->
                  <!--.attr("class", "node")-->
                  <!--.call(force.drag);-->

              <!--// Enter any new nodes.-->
              <!--node.append("circle")-->
                  <!--.attr("class", "node")-->
                  <!--.attr("cx", function(d) { return d.x; })-->
                  <!--.attr("cy", function(d) { return d.y; })-->
                  <!--.style('stroke-width', 3)-->
                  <!--.property("isClicked", false)-->
                  <!--.style("fill", color)-->
                  <!--.attr("r", 0.0)-->
                  <!--.on("contextmenu", contextMenu)-->
                  <!--.call(force.drag)-->


              <!--node.append("text")-->
                  <!--.attr("dx", 10)-->
                  <!--.attr("dy", ".35em")-->
                  <!--.style("opacity", 0.0)-->
                  <!--.text(function(d) { return d.name; })-->
                  <!--.transition()-->
                  <!--.duration(350)-->
                  <!--.style('opacity', 1.0);-->

              <!--// Exit any old nodes.-->
              <!--newNodes.exit().remove();-->

            <!--}-->

            <!--var isFirst = true;-->

            <!--function tick() {-->
              <!--link.attr("x1", function(d) { return d.source.x; })-->
                  <!--.attr("y1", function(d) { return d.source.y; })-->
                  <!--.attr("x2", function(d) { return d.target.x; })-->
                  <!--.attr("y2", function(d) { return d.target.y; });-->

              <!--if (nodes != null) {-->
                <!--nodes.forEach(function(node) {-->
                  <!--if (!node.isCollapsed) {-->
                     <!--if (node.charge > -300.0) {-->
                       <!--node.charge -= node.chargeChange;-->
                       <!--node.chargeChange += 0.3-->
                     <!--}-->
                     <!--if (node.linkDistance < 20.0) {-->
                       <!--node.linkDistance += node.linkDistanceChange * node.growthSpeed;-->
                       <!--node.linkDistanceChange += 0.003-->

                       <!--if (node.linkDistance >= 20.0) {-->
                          <!--var i = 200;-->

                          <!--// expand the children now-->
                          <!--node.children.forEach(function(x) {-->
                            <!--d3.timer(function(elapsed) {-->
                               <!--scalaEventHandler.click("UNFOLDING");-->
                               <!--unfold(x);-->
                               <!--return 1;-->
                            <!--}, i);-->
                            <!--i += 400;-->
                          <!--});-->
                        <!--}-->
                     <!--}-->
                   <!--}-->
                <!--});-->
              <!--}-->

              <!--force.start()-->

             <!--node.on('mouseover', function(d) {-->

              <!--d3.select(this).select("circle").transition()-->
                      <!--.duration(350)-->
                      <!--.attr("r", 10)-->
                      <!--.style('stroke-width', 3);-->

              <!--link.transition()-->
                      <!--.duration(350).style('stroke-width', function(l) {-->
                <!--if (d === l.source || d === l.target)-->
                  <!--return 4;-->
                <!--else-->
                  <!--return 2;-->
                <!--});-->
            <!--});-->

            <!--node.on("click", function (d) {-->
              <!--if (!d.isClicked) {-->
                <!--var clicked = flatten(root).filter(function(i) {-->
                  	<!--return i.isClicked;-->
                  <!--});-->

                <!--d.isClicked = true;-->

                <!--clicked.select("circle").transition()-->
                        <!--.duration(350)-->
                        <!--.style('stroke', '#000000')-->
                        <!--.style('stroke-width', 0.5);-->

                <!--d3.select(this).select("circle").transition()-->
                        <!--.duration(350)-->
                        <!--.style('stroke', '#FF0000');-->

                <!--clicked.each(function(i) {-->
                  <!--i.isClicked = false;-->
                <!--});-->
              <!--}-->
				    <!--});-->

            <!--node.on("mouseout", function (d) {-->
				      <!--link.transition()-->
                      <!--.duration(350).style('stroke-width', 2);-->

				      <!--d3.select(this).select("circle").transition()-->
                      <!--.duration(350)-->
                      <!--.attr("r", 5)-->
                      <!--.style('stroke-width', function (x) {if (x.isClicked) {return 3;} else return 0.5;})-->
                      <!--.style('stroke', function (x) {if (x.isClicked) {return '#FF0000';} else return '#000000';});-->
				    <!--});-->

            <!--d3.selectAll("circle").attr("cx", function (d) {-->
                    <!--return d.x;-->
                <!--})-->
                    <!--.attr("cy", function (d) {-->
                    <!--return d.y;-->
                <!--});-->

                <!--d3.selectAll("text").attr("x", function (d) {-->
                  <!--return d.x;-->
              <!--})-->
                  <!--.attr("y", function (d) {-->
                  <!--return d.y;-->
              <!--});-->
            <!--}-->

            <!--// Color leaf nodes orange, and packages white or blue.-->
            <!--function color(d) {-->
              <!--return d._children.length > 0 ? "#3182bd" : d.children.length > 0 ? "#c6dbef" : "#fd8d3c";-->
            <!--}-->

            <!--function openNode(d) {-->
              <!--d.linkDistance = 0.0-->
              <!--d.isCollapsed = false-->
              <!--var node = d._children[0]-->
              <!--node.isCollapsed = true // children start out closed-->
              <!--node.x = d.x;-->
              <!--node.y = d.y;-->
              <!--node.px = d.x;-->
              <!--node.py = d.y;-->
              <!--node.charge = 0-->
              <!--node.linkStrength = 0.0-->
              <!--node.chargeChange = 0.0-->
              <!--node.linkDistance = 0.0-->

              <!--d.children.push(d._children.shift());-->
            <!--}-->

            <!--// Toggle expansion on right-click.-->
            <!--function contextMenu(d) {-->
              <!--openNode(d);-->
              <!--update();-->
            <!--}-->

            <!--// Returns a list of all nodes under the root.-->
            <!--function flatten(root) {-->
              <!--var nodes = [], i = 0;-->

              <!--function recurse(node) {-->
                <!--if (node.children) node.size = node.children.reduce(function(p, v) { return p + recurse(v); }, 0);-->
                <!--if (!node.id) node.id = ++i;-->
                <!--nodes.push(node);-->
                <!--return node.size;-->
              <!--}-->

              <!--root.size = recurse(root);-->
              <!--return nodes;-->
            <!--}-->

            <!--function flattenClosed(root) {-->
              <!--var nodes = [], i = 0;-->

              <!--function recurse(node) {-->
                <!--if (node._children) node.size = node._children.reduce(function(p, v) { return p + recurse(v); }, 0);-->
                <!--if (!node.id) node.id = ++i;-->
                <!--nodes.push(node);-->
                <!--return node.size;-->
              <!--}-->

              <!--root.size = recurse(root);-->
              <!--return nodes;-->
            <!--}-->
    <!--})-->
<!--</script>-->


</body>
</html>